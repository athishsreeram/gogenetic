package main

import (
	"html/template"
	"log"
	"os"

	"io/ioutil"

	"github.com/BurntSushi/toml"

	"flag"
	"strings"
)

var fns = template.FuncMap{
	"plus1": func(x int) int {
		return x + 1
	}, "minus1": func(x int) int {
		x = x - 1
		return x
	}, "convertswagger": func(x string) string {
		if x == "int" {
			return "integer"
		}
		if x == "string" {
			return "string"
		}
		return ""
	}, "convertproto": func(x string) string {
		if x == "int" {
			return "int64"
		}
		if x == "string" {
			return "string"
		}
		if x == "repeated" {
			return "repeated"
		}
		if x == "object" {
			return "object"
		}
		if x == "boolean" {
			return "bool"
		}
		return ""
	}, "lowercase": func(x string) string {
		return strings.ToLower(x)
	}, "titlecase": func(x string) string {
		return strings.Title(x)
	}, "uppercase": func(x string) string {
		return strings.ToUpper(x)
	}, "removeplural": func(x string) string {
		a := []rune(x)
		return string(a[0 : len(a)-1])
	}, "firstsmall": func(x string) string {
		a := []rune(x)

		var msgStr strings.Builder
		msgStr.WriteString(strings.ToLower(string(a[0:1])))
		msgStr.WriteString(string(a[1:len(a)]))

		return msgStr.String()
	},
}

// AutoGenerated Create & copied from https://xuri.me/toml-to-go/
type AutoGenerated struct {
	Architechture struct {
		Name      string `toml:"Name"`
		Outputdir string `toml:"Outputdir"`
	} `toml:"Architechture"`
	API struct {
		Name       string `toml:"Name"`
		Operations []struct {
			URL         string `toml:"url"`
			Request     string `toml:"request"`
			Response    string `toml:"response"`
			Protocol    string `toml:"protocol"`
			Operationid string `toml:"operationid"`
		} `toml:"Operations"`
	} `toml:"API"`
	Models struct {
		Model []struct {
			Name     string `toml:"name"`
			Variable []struct {
				Name  string `toml:"name"`
				Value string `toml:"value"`
				Type  string `toml:"type"`
			} `toml:"Variable"`
		} `toml:"Model"`
	} `toml:"Models"`
	DomainModels struct {
		DomainModel []struct {
			Name     string `toml:"name"`
			Variable []struct {
				Name   string `toml:"name"`
				Value  string `toml:"value"`
				Type   string `toml:"type"`
				Dbtype string `toml:"dbtype"`
			} `toml:"Variable"`
		} `toml:"DomainModel"`
	} `toml:"DomainModels"`
	Mapping struct {
		Map []struct {
			Name            string `toml:"name"`
			From            string `toml:"from"`
			To              string `toml:"to"`
			Type            string `toml:"type"`
			VariableMapping []struct {
				From string `toml:"from"`
				To   string `toml:"to"`
				Type string `toml:"type"`
			} `toml:"VariableMapping"`
		} `toml:"Map"`
	} `toml:"Mapping"`
	CommandToEvent struct {
		Command []struct {
			Name   string `toml:"name"`
			Events []struct {
				Name string `toml:"name"`
			} `toml:"events"`
		} `toml:"Command"`
	} `toml:"CommandToEvent"`
}

// Create & copied from https://xuri.me/toml-to-go/

func check(e error) {
	if e != nil {
		panic(e)
	}
}

func fileloc(templateFile string) string {
	if strings.Contains(templateFile, "proto-") {
		return "proto/"
	}
	if strings.Contains(templateFile, "cmd") {
		return "cmd/main/"
	}
	if strings.Contains(templateFile, "grpcserver") {
		return "server/grpc/"
	}
	if strings.Contains(templateFile, "grpcrestserver") {
		return "server/rest/"
	}
	if strings.Contains(templateFile, "servicetodomain") {
		return "servicetodomain/"
	}
	if strings.Contains(templateFile, "service") {
		return "service/v1/"
	}
	if strings.Contains(templateFile, "grpcclient") {
		return "client/grpc/v1/"
	}
	if strings.Contains(templateFile, "domain") {
		return "domain/"
	}
	if strings.Contains(templateFile, "natspubclient") {
		return "client/nats/pub/"
	}
	if strings.Contains(templateFile, "natssubclient") {
		return "client/nats/sub/"
	}
	if strings.Contains(templateFile, "natsconutilclient") {
		return "client/nats/con/"
	}
	if strings.Contains(templateFile, "config") {
		return "config/"
	}
	if strings.Contains(templateFile, "commandtoevent") {
		return "servicetodomain/"
	}

	return ""

}

func fileName(templateFile string, apiName string) string {

	if strings.Contains(templateFile, "proto-") {
		return apiName + "-service.proto"
	}
	if strings.Contains(templateFile, "cmd") {
		return apiName + "-cmdserver.go"
	}
	if strings.Contains(templateFile, "grpcserver") {
		return apiName + "-server.go"
	}
	if strings.Contains(templateFile, "grpcrestserver") {
		return apiName + "-rest-server.go"
	}
	if strings.Contains(templateFile, "swagger") {
		return apiName + "-swagger.yml"
	}
	if strings.Contains(templateFile, "servicetodomain") {
		return apiName + "-EventHandler.go"
	}
	if strings.Contains(templateFile, "servicebasic") {
		return apiName + "-service.go"
	}
	if strings.Contains(templateFile, "servicenats") {
		return apiName + "-nat-service.go"
	}
	if strings.Contains(templateFile, "serviceasyncnats") {
		return apiName + "-nat-service.go"
	}
	if strings.Contains(templateFile, "servicecrud") {
		return apiName + "-crud-service.go"
	}
	if strings.Contains(templateFile, "grpcclient") {
		return apiName + "-client.go"
	}
	if strings.Contains(templateFile, "esdomain") {
		return apiName + "-esdomain.go"
	}
	if strings.Contains(templateFile, "domain") {
		return apiName + "-domain.go"
	}
	if strings.Contains(templateFile, "natspubclient") {
		return apiName + "-pub-client.go"
	}
	if strings.Contains(templateFile, "natssubclient") {
		return apiName + "-sub-client.go"
	}
	if strings.Contains(templateFile, "natsconutilclient") {
		return apiName + "-nats-util-client.go"
	}
	if strings.Contains(templateFile, "config") {
		return apiName + "-config.go"
	}
	if strings.Contains(templateFile, "devconf") {
		return "config-dev.json"
	}
	if strings.Contains(templateFile, "commandtoevent") {
		return apiName + "-CommandHandler.go"
	}
	if strings.Contains(templateFile, "liquibase") {
		return apiName + "-liqubase.xml"
	}

	return ""

}

func createDirIfNotExist(dir string) {
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		err = os.MkdirAll(dir, 0755)
		if err != nil {
			panic(err)
		}
	}
}

func main() {

	dir, err := os.Getwd()
	if err != nil {
		log.Fatal(err)
	}
	log.Println(dir)

	//0. Argument Options Simple CLI with go-command-line-flags
	tomlFile := flag.String("tomlFile", dir+"/toml/test.toml", " Input the TOML File.")
	templateFile := flag.String("templateFile", dir+"/template/go/grpctemplate.goproto", " Input the TOML File.")
	outDir := flag.String("outDir", dir+"/template/go/grpctemplate.goproto", " Input the TOML File.")
	flag.Parse()

	//go run gogentic.go /Users/anharay/go/src/gogenetic/toml/test.toml /Users/anharay/go/src/gogenetic/template/grpctemplate.goproto
	//1. Load TOML file
	tomlData, err := ioutil.ReadFile(*tomlFile)
	check(err)
	//log.Print("Parsed TOML")
	//log.Print(string(tomlData))

	//2. Load Template
	tmpl, err := ioutil.ReadFile(*templateFile)
	check(err)
	//log.Print("Parsed Template")
	//log.Print(string(tmpl))

	//3. Parse & Load value dynamically
	var conf AutoGenerated
	if _, err := toml.Decode(string(tomlData), &conf); err != nil {
		log.Fatal(err)
	}
	//log.Print("Parsed & Load value into Generated Structs from Create & copied from https://xuri.me/toml-to-go/")
	//log.Printf("title: %s", conf.Architechture.Name)

	//log.Print("Create a goTemplate and Pass TOML struts Value to create the final grpc file")
	//4. Create Template and Pass TOML Value
	t := template.New("GRPC template")

	t1, err := t.Funcs(fns).Parse(string(tmpl))
	if err != nil {
		log.Fatal("Parse: ", err)
		return
	}
	log.Println("Output:" + dir + "/" + *outDir + "/" + fileloc(*templateFile) + fileName(*templateFile, conf.API.Name))
	createDirIfNotExist(dir + "/" + *outDir + "/" + fileloc(*templateFile))

	f, err := os.Create(dir + "/" + *outDir + "/" + fileloc(*templateFile) + fileName(*templateFile, conf.API.Name))
	if err != nil {
		log.Println("create file: ", err)
		return
	}

	// set out dir into conf
	conf.Architechture.Outputdir = *outDir

	err = t1.Execute(f, conf)
	if err != nil {
		log.Fatal("Execute: ", err)
		return
	}

	f.Close()

}
